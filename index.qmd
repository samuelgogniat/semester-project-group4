---
title: The title of your Semesterproject
subtitle: A subtle subtitle
author: Firstname1 Lastname1 and Firstname2 Lastname2
output: html
editor_options: 
  chunk_output_type: console
---

<!-- You can add  your R Code with Code chunks-->

```{r}
#| echo: false
#| warning: false
#| message: false

# You can set chunk options individually per code chunk, as was done with this
# code chunk.

# echo: false           hides the code from the generated output
# warning: false        hides warnings from the generated output

# message: false        hides messages from the generated output

# To apply the setting for all code chunks, add the options to the yaml header of the document (in between the ---) without the preceeding "#|".

```

## Abstract

<!-- the following is just a placeholder text, remove it!-->

Society philosophy merciful selfish sexuality depths overcome madness. Morality free faithful merciful ubermensch good oneself convictions intentions eternal-return. Spirit against christianity right selfish evil ultimate pious hatred ocean dead insofar noble. Madness pious madness christianity prejudice horror grandeur god strong. Ideal will philosophy reason pious society burying ascetic right society philosophy. Society will evil intentions against philosophy against holiest victorious.

## Introduction

<!-- the following is just a placeholder text, remove it!-->

Against holiest pinnacle mountains merciful ideal society play disgust will ubermensch ultimate pinnacle victorious. Snare value law gains battle pious intentions revaluation strong. Insofar snare faith ideal oneself.

```{r}
library(ggplot2)

# Include tables with the function "kable"

knitr::kable(head(mtcars))
```

<!-- the following is just a placeholder text, remove it!-->

Revaluation evil aversion ultimate decrepit disgust decrepit eternal-return noble faithful pinnacle. Truth ascetic inexpedient decrepit free. Ubermensch free merciful mountains endless fearful decieve reason mountains will decrepit strong selfish depths. Overcome faith snare gains oneself transvaluation.

```{r}
# include plots automatically

ggplot(mtcars, aes(cyl, disp)) +
  geom_point()

```

## Material and Methods

<!-- the following is just a placeholder text, remove it!-->

Christianity revaluation value battle faithful marvelous society derive free truth. Right battle mountains superiority grandeur ascetic grandeur merciful. Derive against intentions burying salvation ocean. Right intentions dead victorious ideal spirit evil ultimate joy. Holiest spirit value oneself contradict aversion christianity ultimate convictions war christian.

```{r}
#| echo: false
#| warning: false
#| message: false


#data preperation

library("readr")
library("dplyr")
library("sf")
library("ggplot2")
library("dplyr")
library("zoo")
library("tmap")
library("lubridate")
library("tidyr")


data <- read_delim("posmo_data/posmo_v1.csv")
head(data)

data <- select(data, datetime, transport_mode, lon_x, lat_y) # Keep only the necessary columns

data <- st_as_sf(data, coords = c("lon_x","lat_y"), crs = 4326) |>  #cs is transformed to 2056
  st_transform(2056)

data_coord <- st_coordinates(data) #coordinates are extracted
data <- cbind(data, data_coord) #coordinates are binded in separate columns

data <- data |> 
  filter(as.Date(datetime) < "2023-04-14" | as.Date(datetime) > "2023-04-17") #delet days which I wasn't in switzerland. Could that be done by cutting all trajectories to switzerland?
```

```{r}
#| echo: false
#| warning: false
#| message: false

#data pre-processing

#choose two single days for trial:
data_1 <- data |>
    filter(as.Date(datetime) == "2023-04-27") # a second interesting date: "2023-04-21"

# Step 1: calculating timelag

data_1 <- data_1 |>
  mutate(timelag = as.numeric(difftime(lead(datetime), datetime, units = "secs"))) 

# Step 2: Identify rows with gaps (definied as more than 10s)

data_1 <- data_1 |> 
  mutate(gap = timelag > 10)

# Step 3: Assign segment IDs according to gaps

data_1 <- data_1 |> 
  mutate(segment_id = cumsum(gap))

# Step 4: Calculate moving window of stepMean (window of 6 fixes: 30s)

data_1 <- data_1 |> 
  group_by(segment_id) |>
    mutate(
    stepMean = rowMeans(
      cbind(
        sqrt((lag(X, 3) - X)^2 + (lag(Y, 3) - Y)^2),
        sqrt((lag(X, 2) - X)^2 + (lag(Y, 2) - Y)^2),
        sqrt((lag(X, 1) - X)^2 + (lag(Y, 1) - Y)^2),
        sqrt((X - lead(X, 1))^2 + (Y - lead(Y, 1))^2),
        sqrt((X - lead(X, 2))^2 + (Y - lead(Y, 2))^2),
        sqrt((X - lead(X, 3))^2 + (Y - lead(Y, 3))^2)
      )
    )
  )
  

# Step 5: Create the "static" column. StepMean below 2m per 5s -> static


data_1 <- data_1 %>%
  mutate(static = if_else(is.na(stepMean) | stepMean < 2, T, F))

#plot for a first look:

ggplot(data_1, aes(X, Y, color=static))+ 
  geom_point()+
  geom_path()+
  coord_equal()

# Step 6: split up to smaller segments according to static/non-static 

rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
} #function to assign unique ID for each segment

data_1 <- data_1 |>
   ungroup() |> 
    mutate(segment_id = rle_id(static))

# Step 7: filter out all non-static points

data_1 <- data_1 |> 
    filter(!static)

# plot for a look

ggplot(data_1,aes(X, Y, color = segment_id)) +
    geom_path() +
    geom_point() +
    coord_fixed() +
    theme(legend.position = "none")

# Step 8: filter out small segments (definied as less than 2mins or less than 200m)

data_1 <- data_1 |> 
  group_by(segment_id) |> 
  mutate(steplength = sqrt((X - lead(X, 1)) ^ 2 + (Y - lead(Y, 1)) ^ 2)) |> 
  filter(sum(steplength, na.rm=T)>200) 

# plot for a lok

ggplot(data_1,aes(X, Y, color = segment_id)) +
    geom_path() +
    geom_point() +
    coord_fixed() +
    theme(legend.position = "none")

# plot for a last time

tmap_mode("view") 
tm_shape(data_1)+
  tm_dots(col="segment_id")

```


```{r}
#| echo: false
#| warning: false
#| message: false

#apply on whole dataset


data <- data |>
  mutate(
    timelag = as.numeric(difftime(lead(datetime), datetime, units = "secs")), 
    gap = timelag > 10,
    segment_id = cumsum(gap)
  )

data <- data |> 
  group_by(segment_id) |>
    mutate(
    stepMean = rowMeans(
      cbind(
        sqrt((lag(X, 3) - X)^2 + (lag(Y, 3) - Y)^2),
        sqrt((lag(X, 2) - X)^2 + (lag(Y, 2) - Y)^2),
        sqrt((lag(X, 1) - X)^2 + (lag(Y, 1) - Y)^2),
        sqrt((X - lead(X, 1))^2 + (Y - lead(Y, 1))^2),
        sqrt((X - lead(X, 2))^2 + (Y - lead(Y, 2))^2),
        sqrt((X - lead(X, 3))^2 + (Y - lead(Y, 3))^2)
      )
    ),
    static = if_else(is.na(stepMean) | stepMean < 2, T, F)
  )
  

rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
} #function to assign unique ID for each segment

data <- data |>
   ungroup() |> 
    mutate(segment_id = rle_id(static)) |> 
    filter(!static)

data <- data |> 
  group_by(segment_id) |> 
  mutate(steplength = sqrt((X - lead(X, 1)) ^ 2 + (Y - lead(Y, 1)) ^ 2)) |> 
  filter(sum(steplength, na.rm=T)>200) 

ggplot(data,aes(X, Y, color = segment_id)) +
    geom_path() +
    geom_point() +
    coord_fixed() +
    theme(legend.position = "none")

```



```{r}
#calculate moving parameters

data <- data |> 
  group_by(segment_id) |> 
  mutate(
    speed = {
      step_minus2 <- sqrt((lag(X, 2) - X) ^ 2 + (lag(Y, 2) - Y) ^ 2)
      time_minus2 <- abs(as.numeric(difftime(lag(datetime, 2), datetime, units = "secs")))
      step_plus2 <- sqrt((X - lead(X, 2)) ^ 2 + (Y - lead(Y, 2)) ^ 2)
      time_plus2 <- as.numeric(difftime(lead(datetime, 2), datetime, units = "secs"))
      (step_minus2/time_minus2 + step_plus2/time_plus2) / 2
    },
    acc = {
      speed_minus2 <- speed - lag(speed, 2)
      speed_plus2 <- lead(speed, 2) - speed
      time_minus2 <- abs(as.numeric(difftime(lag(datetime, 2), datetime, units = "secs")))
      time_plus2 <- as.numeric(difftime(lead(datetime, 2), datetime, units = "secs"))
      (speed_minus2/time_minus2 + speed_plus2/time_plus2) / 2   
      },
    sin = {
      d_minus1 <- sqrt((lag(X, 1) - X) ^ 2 + (lag(Y, 1) - Y) ^ 2)
      d_minus2 <- sqrt((lag(X, 2) - lag(X, 1)) ^ 2 + (lag(Y, 2) - lag(Y, 1)) ^ 2)
      d_plus1  <- sqrt((X - lead(X, 1))^2 + (Y - lead(Y, 1))^2)
      d_plus2  <- sqrt((lead(X, 1) - lead(X, 2))^2 + (lead(Y,1) - lead(Y, 2))^2)
      d_straight <- sqrt((lag(X, 2) - lead(X, 2))^2 + (lag(Y,2) - lead(Y, 2))^2)
      (d_minus1 + d_minus2 + d_plus1 + d_plus2)/d_straight
    }
  )

#filter with sinousity

data <- data |> 
  group_by(segment_id) |> 
  filter(mean(sin, na.rm=T)<2) 

```

```{r}
#allocate nearest road using SWISSTLM3d
roads <- read_sf("background_data/swisstlm3d_2023-03_2056_5728.shp/TLM_STRASSEN/swissTLM3D_TLM_STRASSE.shp")
roads <- select(roads, OBJEKTART, geometry)
rails <- read_sf("background_data/swisstlm3d_2023-03_2056_5728.shp/TLM_OEV/swissTLM3D_TLM_EISENBAHN.shp")
rails <- select(rails, OBJEKTART, geometry)
boats <- read_sf("background_data/swisstlm3d_2023-03_2056_5728.shp/TLM_OEV/swissTLM3D_TLM_SCHIFFFAHRT.shp")
boats <- select(boats, OBJEKTART, geometry)

background_data <- rbind(roads, rails, boats)
background_data <- st_transform(background_data, 2056)
data <- st_join(data, background_data, join = st_nearest_feature)


#visualization part of it to see how good it is #not working yet


```

```{r}
#summarize all

#calculate summary

data$transport_mode <- as.factor(data$transport_mode)
data$OBJVAL <- as.factor(data$OBJEKTART)
data_smry <- data |> 
  group_by(segment_id) |> 
  summarise(
            mean_speed = mean(speed, na.rm=T),
            max_speed = max(speed,na.rm=T),
            min_speed = min(speed,na.rm=T),
            mean_acc = mean(acc, na.rm=T),
            max_acc = max(acc,na.rm=T),
            min_acc = min(acc,na.rm=T),
            mean_sin = mean(sin, na.rm=T),
            max_sin = max(sin,na.rm=T),
            min_sin = min(sin,na.rm=T),
            transport_mode = levels(transport_mode)[which.max(table(transport_mode))],
            nearest_route = levels(OBJEKTART)[which.max(table(OBJEKTART))]

  )


#export for classification

write.csv(data_smry, "output_files/data_smry.csv")

#plot for EDA

data_smry_long <- pivot_longer(data_smry, 
                           cols = -c("segment_id","transport_mode","geometry"),
                           names_to = "parameter") 

ggplot(data_smry_long, aes(x=transport_mode, y=value, fill=transport_mode))+
  geom_boxplot()+
  facet_wrap(~parameter, scales="free_y")+
  theme_bw()+
  theme(
    axis.title.x = element_blank(),
  )
```

## SEVI: TLM

Load datas, preparing and cropping them to canton of zuerich

```{r}

#layers <- st_layers("background_data/SWISSTLM3D_2023_LV95_LN02.gpkg")

#roads <- read_sf("background_data/SWISSTLM3D_2023_LV95_LN02.gpkg", layer = "tlm_strassen_strasse")
#stops <- read_sf("background_data/SWISSTLM3D_2023_LV95_LN02.gpkg", layer = "tlm_oev_haltestelle")
#rail <- read_sf("background_data/SWISSTLM3D_2023_LV95_LN02.gpkg", layer = "tlm_oev_eisenbahn")
swiss <- read_sf("background_data/swissBOUNDARIES3D_1_4_TLM_LANDESGEBIET.shp")
canton <- read_sf("background_data/swissBOUNDARIES3D_1_4_TLM_KANTONSGEBIET.shp")
district <- read_sf("background_data/swissBOUNDARIES3D_1_4_TLM_BEZIRKSGEBIET.shp")
plot(canton)
plot(swiss)

zurich <- canton |> 
  filter(NAME=="Zürich")
zurich <- zurich |> 
  select(c(NAME, geometry))
plot(zurich)

horgen <- district |> 
  filter(NAME=="Horgen" & BEZIRK_TEI==1)
horgen <- horgen |> 
  select(NAME, geometry)
plot(horgen)

roads <- st_transform(roads, st_crs(zurich))
stops <- st_transform(stops, st_crs(zurich))
rail <- st_transform(rail, st_crs(zurich))

intersect_roads <- st_intersection(roads, zurich)
intersect_stops <- st_intersection(stops, zurich)
intersect_rail <- st_intersection(rail, zurich)

plot(intersect_rail$geom)
plot(intersect_roads$geom)
plot(intersect_stops$geom)

intersect_roads <- intersect_roads |> 
  select(c(objektart, verkehrsbedeutung, geom))
st_write(intersect_roads,"output_files/intersect_roads.gpkg")

intersect_rail <- intersect_rail |> 
  select(c(objektart, auf_strasse, verkehrsmittel, geom))
st_write(intersect_rail,"output_files/intersect_rail.gpkg")

intersect_stops <- intersect_stops |> 
  select(c(objektart, name, geom))
st_write(intersect_stops,"output_files/intersect_stops.gpkg")

intersect_roads <- read_sf("output_files/intersect_roads.gpkg")
intersect_rail <- read_sf("output_files/intersect_rail.gpkg")
intersect_stops <- read_sf("output_files/intersect_stops.gpkg")

```

## Intersect data before filtering data

nrow(data_swiss) ist etwas klein....vielleicht nachprüfen oder mit Sämi besprechen

```{r}
data_sevi <- read_delim("posmo_data/posmo_v1.csv")
head(data_sevi)

data_sevi <- select(data_sevi, datetime, transport_mode, lon_x, lat_y) # Keep only the necessary columns

data_sevi <- st_as_sf(data_sevi, coords = c("lon_x","lat_y"), crs = 4326) |>  #cs is transformed to 2056
  st_transform(2056)

data_coord_sevi <- st_coordinates(data_sevi) #coordinates are extracted
data_sevi <- cbind(data_sevi, data_coord_sevi) #coordinates are binded in separate columns

swiss <- read_sf("background_data_small/swissBOUNDARIES3D_1_4_TLM_LANDESGEBIET.shp")
canton <- read_sf("background_data_Small/swissBOUNDARIES3D_1_4_TLM_KANTONSGEBIET.shp")
district <- read_sf("background_data_small/swissBOUNDARIES3D_1_4_TLM_BEZIRKSGEBIET.shp")

zurich <- canton |> 
  filter(NAME=="Zürich")
zurich <- zurich |> 
  select(c(NAME, geometry))

horgen <- district |> 
  filter(NAME=="Horgen" & BEZIRK_TEI==1)
horgen <- horgen |> 
  select(NAME, geometry)

data <- st_transform(data_sevi, "+init=EPSG:2056")
st_crs(swiss) <-  "+init=EPSG:2056"

zurich <- st_transform(zurich, "+init=EPSG:2056")
horgen <- st_transform(horgen, "+init=EPSG:2056")


data_swiss <- read_delim("output_files/data_swiss.csv")
#data_swiss <- st_intersection(data, swiss)
#write_delim(data_swiss, "output_files/data_swiss.csv")


data_zurich <- st_intersection(data_sevi, zurich)

data_horgen <- st_intersection(data_sevi, horgen)


#Timelag
data_swiss <- data_swiss |>
  mutate(timelag = as.numeric(difftime(lead(datetime), datetime, units = "secs")))

data_zurich <- data_zurich |>
  mutate(timelag = as.numeric(difftime(lead(datetime), datetime, units = "secs")))

data_horgen <- data_horgen |>
  mutate(timelag = as.numeric(difftime(lead(datetime), datetime, units = "secs")))

#Gap
data_swiss <- data_swiss %>%
  mutate(gap = timelag > 10)

data_zurich <- data_zurich %>%
  mutate(gap = timelag > 10)

data_horgen <- data_horgen %>%
  mutate(gap = timelag > 10)


#Segment ID
data_swiss <- data_swiss %>%
  mutate(segment_id = cumsum(gap))

data_zurich <- data_zurich %>%
  mutate(segment_id = cumsum(gap))

data_horgen <- data_horgen %>%
  mutate(segment_id = cumsum(gap))


#Steplength
data_swiss <- data_swiss %>%
  group_by(segment_id) %>%
  mutate(
    step_length = sqrt((lead(X, 1) - X) ^ 2 + (lead(Y, 1) - Y) ^ 2),
    sum_step_length = rollsum(step_length, k = 12, fill = NA, align = "right", na.rm = TRUE)
  ) %>%
  ungroup()

data_zurich <- data_zurich %>%
  group_by(segment_id) %>%
  mutate(
    step_length = sqrt((lead(X, 1) - X) ^ 2 + (lead(Y, 1) - Y) ^ 2),
    sum_step_length = rollsum(step_length, k = 12, fill = NA, align = "right", na.rm = TRUE)
  ) %>%
  ungroup()

data_horgen <- data_horgen %>%
  group_by(segment_id) %>%
  mutate(
    step_length = sqrt((lead(X, 1) - X) ^ 2 + (lead(Y, 1) - Y) ^ 2),
    sum_step_length = rollsum(step_length, k = 12, fill = NA, align = "right", na.rm = TRUE)
  ) %>%
  ungroup()

#Static
data_swiss <- data_swiss %>%
  mutate(static = if_else(is.na(sum_step_length) | sum_step_length < 25, T, F))
ggplot(data_swiss, aes(X, Y)) +
  geom_path() +
  geom_point() +
  coord_fixed() +
  theme_bw()+
  theme(legend.position = "none")

data_zurich <- data_zurich %>%
  mutate(static = if_else(is.na(sum_step_length) | sum_step_length < 25, T, F))
ggplot(data_zurich, aes(X, Y)) +
  geom_path() +
  geom_point() +
  coord_fixed() +
  theme_bw()+
  theme(legend.position = "none")

data_horgen <- data_horgen %>%
  mutate(static = if_else(is.na(sum_step_length) | sum_step_length < 25, T, F))
ggplot(data_horgen, aes(X, Y)) +
  geom_path() +
  geom_point() +
  coord_fixed() +
  theme_bw()+
  theme(legend.position = "none")

#RLE ID Function
rle_id <- function(vec) {
  x <- rle(vec)$lengths
  as.factor(rep(seq_along(x), times = x))
} 

#Segment ID
data_swiss <- data_swiss |>
  mutate(segment_id = rle_id(static))

data_zurich <- data_zurich |>
  mutate(segment_id = rle_id(static))

data_horgen <- data_horgen |>
  mutate(segment_id = rle_id(static))

#Filter Movement
data_swiss <- data_swiss |> 
  filter(!static)

data_zurich <- data_zurich |> 
  filter(!static)

data_horgen <- data_horgen |> 
  filter(!static)

#Filter short segment IDs
data_swiss <- data_swiss |> 
  group_by(segment_id) |> 
  filter(sum(timelag, na.rm = T) > 120) |> 
  filter(sum(step_length, na.rm = T) > 200)

data_zurich <- data_zurich |> 
  group_by(segment_id) |> 
  filter(sum(timelag, na.rm = T) > 120) |> 
  filter(sum(step_length, na.rm = T) > 200)

data_horgen <- data_horgen |> 
  group_by(segment_id) |> 
  filter(sum(timelag, na.rm = T) > 120) |> 
  filter(sum(step_length, na.rm = T) > 200)

#Plot

ggplot(data_swiss, aes(X, Y, color = segment_id)) +
  geom_path() +
  geom_point() +
  coord_fixed() +
  theme(legend.position = "none")

ggplot(data_zurich, aes(X, Y, color = segment_id)) +
  geom_path() +
  geom_point() +
  coord_fixed() +
  theme(legend.position = "none")

ggplot(data_horgen, aes(X, Y, color = segment_id)) +
  geom_path() +
  geom_point() +
  coord_fixed() +
  theme(legend.position = "none")

ggplot(data_swiss, aes(X, Y, color = segment_id)) +
  geom_path() +
  geom_point() +
  coord_fixed() +
  theme_bw()+
  theme(legend.position = "none")

ggplot(data_zurich, aes(X, Y, color = segment_id)) +
  geom_path() +
  geom_point() +
  coord_fixed() +
  theme_bw()+
  theme(legend.position = "none")

ggplot(data_horgen, aes(X, Y, color = segment_id)) +
  geom_path() +
  geom_point() +
  coord_fixed() +
  theme_bw()+
  theme(legend.position = "none")

#Speed
data_swiss <- data_swiss|> 
  mutate(speed = step_length/timelag) 

data_zurich <- data_zurich|> 
  mutate(speed = step_length/timelag) 

data_horgen<- data_horgen|> 
  mutate(speed = step_length/timelag) 

#Mean, max und min speed
data_swiss_smry <- data_swiss |> 
  filter(timelag != 0) |> 
  group_by(segment_id, transport_mode) |> 
  summarise(mean_speed = mean(speed, na.rm=T),
            max_speed = max(speed,na.rm=T),
            min_speed = min(speed,na.rm=T))

data_zurich_smry <- data_zurich |> 
  filter(timelag != 0) |> 
  group_by(segment_id, transport_mode) |> 
  summarise(mean_speed = mean(speed, na.rm=T),
            max_speed = max(speed,na.rm=T),
            min_speed = min(speed,na.rm=T))

data_horgen_smry <- data_horgen |> 
  filter(timelag != 0) |> 
  group_by(segment_id, transport_mode) |> 
  summarise(mean_speed = mean(speed, na.rm=T),
            max_speed = max(speed,na.rm=T),
            min_speed = min(speed,na.rm=T))


?sf


```



## Results

<!-- the following is just a placeholder text, remove it!-->

Philosophy oneself passion play fearful self noble zarathustra deceptions sexuality. Endless ocean of oneself dead ocean. Selfish decrepit.

## Discussion

<!-- the following is just a placeholder text, remove it!-->

Justice convictions spirit sexuality insofar free marvelous joy. Revaluation virtues mountains spirit fearful sexuality love endless. Society intentions will noble burying aversion moral. Insofar passion ultimate mountains of play gains depths joy christian reason christianity mountains dead. Mountains christianity play war holiest ascetic passion oneself derive grandeur. Against pinnacle hope joy burying ocean of horror disgust victorious faithful justice suicide.
